import time
from datetime import datetime
import json
import socket
import threading
import os
import requests
import re
import sys

from dotenv import load_dotenv, find_dotenv

load_dotenv(find_dotenv())

BIND_IP = os.getenv('BIND_IP')
BIND_PORT = int(os.getenv('BIND_PORT'))
MESSAGE_RELAY_ADDR = os.getenv('MESSAGE_RELAY_ADDR')
MESSAGE_RELAY_BEARER_TOKEN = os.getenv('MESSAGE_RELAY_BEARER_TOKEN')


def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind((BIND_IP, BIND_PORT))
    server.listen(5)

    print('Listening on {}:{}'.format(BIND_IP, BIND_PORT))

    # accept_connections(server)
    request = b'\n9EC40027"ADM-CID"0001L0#1002[#1002|1602 00 001]\r'
    process_request_data(request)
    send_nak_message(None, request)

    server.close()


def accept_connections(server):
    while True:
        client_sock = None

        try:
            client_sock, address = server.accept()

            print('')
            print('Accepted connection from {}:{}'.format(
                address[0], address[1]))

            client_handler = threading.Thread(
                target=handle_client_connection,
                args=(client_sock,)
            )

            client_handler.start()
        except Exception as e:
            print('{} in accept_connections'.format(e))
            if client_sock:
                print('Closing client socket in accept_connections.')
                client_sock.close()
            break


def handle_client_connection(client_socket):
    try:
        request = client_socket.recv(1024)

        process_request_data(request)

        send_ack_message(client_socket, request)

        client_socket.close()
    except Exception as e:
        print('{} in handle_client_connection'.format(e))
        if client_socket:
            print('Closing client socket in handle_client_connection')
            client_socket.close()

        raise Exception


def process_request_data(request: bytes):
    # example payload: b'\n9EC40027"ADM-CID"0001L0#1002[#1002|1602 00 001]\r'
    print(request)
    payload = request.decode('ASCII')

    # \n
    lf = payload[0]

    # \r
    cr = payload[-1]

    if lf != '\n' or cr != '\r':
        print('LF or CR characers were missing from the payload.')
        return

    # 4 bytes in Hex-ASCII (e.g. 9EC4)
    crc = int(payload[1:5], 16)

    # <0LLL> (e.g. 0027)
    packet_length_payload = payload[5:9]

    # Packet length converted to decimal int
    packet_length = int(packet_length_payload[1:], 10)

    # Split the payload into managable chunks later
    split_payload = payload.split('"')
    payload_end = split_payload[2]

    # "<ID>" (e.g. "ADC-CID")
    message_protocol_id = split_payload[1]

    # Sequential number generated by the transmitter
    sequence_number = int(payload_end[:4], 10)

    # Reciever number (sometimes omitted)
    reciever_number = None

    try:
        reciever_number = re.findall(r'R[0-9]*#', payload_end)[0]
        reciever_number = int(re.findall(r'[0-9]+', reciever_number)[0], 10)
    except IndexError:
        reciever_number = -1

    # Line number
    line_number = None

    try:
        line_number = re.findall(r'L[0-9]*#', payload_end)[0]
        line_number = int(re.findall(r'[0-9]+', line_number)[0], 10)
    except IndexError:
        line_number = -1

    # All data starts with [ and ends with ]
    message_block = re.findall(r'\[(.*?)\]', payload_end)[0]

    # Parse the message into a JSON format
    parsed_message_json = None

    if message_protocol_id == 'ADM-CID':
        parsed_message_json = parse_adc_cid_message(
            message_block, sequence_number, reciever_number, line_number)
    elif message_protocol_id == 'NULL':
        print('Recieved a NULL message')
    else:
        print('Unsupported message protocol ID, cannot parse: got {}'.format(
            message_protocol_id))
        return

    relay_message_contents(parsed_message_json)


def parse_adc_cid_message(message: str, seq_num: int, rec_num: int, ln_num: int) -> dict:
    message_blocks = message.split('|')

    # starts with a #ACCT, so we drop the pound
    account_number = int(message_blocks[0][1:], 10)

    contact_id = message_blocks[1].split(' ')

    # 1 = New Event or Opening,
    # 3 = New Restore or Closing,
    # 6 = Previously reported condition still present (Status report)
    event_qualifier = int(contact_id[0][0], 10)

    # 3 decimal(!) digits XYZ (e.g. 602)
    event_code = int(contact_id[0][1:], 10)

    # 2 decimal(!) digits GG, 00 if no info (e.g. 01)
    group_or_partion_number = contact_id[1]

    # 3 decimal(!) digits CCC, 000 if no info (e.g. 001)
    zone_number_or_user_number = contact_id[2]

    return {
        'sequence_number': seq_num,
        'reciever_number': rec_num,
        'line_number': ln_num,
        'account_number': account_number,
        'event_qualifier': event_qualifier,
        'event_code': event_code,
        'group_or_partion_number': group_or_partion_number,
        'zone_number_or_user_number': zone_number_or_user_number
    }


def relay_message_contents(data: dict):
    print('Received {}\n  at: {}'.format(
        data, time.asctime(time.localtime(time.time()))))

    headers = {'Authorization': 'Bearer {}'.format(MESSAGE_RELAY_BEARER_TOKEN)}

    r = requests.post(MESSAGE_RELAY_ADDR, json=data,
                      headers=headers)

    print('Sent HTTP request to relay, got {} status'.format(r.status_code))


def generate_crc(request: bytes) -> str:
    crc_table = [
        0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
        0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
        0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
        0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
        0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
        0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
        0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
        0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
        0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
        0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
        0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
        0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
        0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
        0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
        0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
        0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
        0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
        0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
        0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
        0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
        0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
        0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
        0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
        0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
        0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
        0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
        0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
        0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
        0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
        0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
        0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
        0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
    ]

    length = len(request)
    buffer = 0
    crc = 0

    while length:
        length -= 1
        crc = zero_fill_right_shift(crc, 8) ^ (
            crc_table[crc ^ data[buffer] & 0xff])
        buffer += 1

    return crc


def zero_fill_right_shift(val, n):
    return (val >> n) if val >= 0 else ((val + 0x100000000) >> n)


def get_message_length():
    return 100


def generate_timestamp() -> str:
    now = datetime.now()

    timestamp = now.strftime('_%H:%M:%S,%m-%d-%Y')

    return timestamp


def send_ack_message(client_socket, request):
    message = '\nCRC0LLL"ACK"SEQLN#ACCT[]\r'


def send_nak_message(client_socket, request):
    message = '\n{}0{}"NAK"0000R0L0A0[]{}\r'.format(
        generate_crc(request),
        get_message_length(),
        generate_timestamp()
    )


if __name__ == "__main__":
    sys.exit(main())
